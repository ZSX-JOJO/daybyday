# 1：ajax

### 	1.1：APIclod： 

### 	api.ajax：跨域异步请求，支持文件上传

```javascript
api.ajax({
    url: 'http://192.168.1.101:3101/upLoad', //(路径)后台接口地址
    method: 'post', //数据传输方式
    data: {
        values: {
            name: 'haha', //传入的参数，对应postman中的Body
            name: 'haha',
            其他参数
        },
    	headers:{'X-APICloud-AppKey':123456, //请求头 对应postman中的Headers
    		'X-APICloud-AppId':123456
    	}
    }
}, function(ret, err) {  //以下内容搭配dot模版(doT.js)，doT模版适用于页面中相同‘样式’的部分(列表)
ret正确数据（可自定义名称）,err错误数据（可自定义名称）
    if (ret) {
        //api.alert({ msg: JSON.stringify(ret) }); //将从后台得到的数据通过json格式'打印'出来
        var tpl = document.getElementById("tpl").innerHTML; //获取dot模版(将需要使用doT模版进行显示的部分设置id).
         var tempFn = doT.template(tpl); //解析模版(doT.template() dot解析方法 固定用法).[解析完成后赋值(解析的作用就是dot可以完成模板中的dot赋值)]   
         document.getElementById("list").innerHTML = tempFn(ret); //数据插入(将通过后台获得的数据插入到设置的模版地方)[将解析后的原模板(document.getElementById("tpl").innerHTML)插入数据(ret),然后插入list中]
        
    } else {
        //api.alert({ msg: JSON.stringify(err) });
    }
});
---------------------------------------------------------------------------------------------
<div id="list"></div> //模版存放位置(数据插入位置)
<script type="text/x-dot-template" id="tpl"> //dot模板(将需要使用doT模版的位置,使用固定用法进行包括)
<div>...</div> ... <div>...</div> //
</script>
---------------------------------------------------------------------------------------------
```

## 	DOT.JS: 持续更新中......

```JavaScript
---------------------------------------------------------------------------------------------
{{=it}} //直接赋值(it就是指tempFn(ret)中的ret)  例如{{=it.data.user_name}}

//若需要遍历 建议 tempFn(ret.data) 栗子如下: 乳此甚好
html:
{{for(var i in it){}}
	{{=it[i].recharge_addtime}}
{{}}}

js:
document.getElementById("doT-Html").innerHTML = doT.template(document.getElementById("doT-Template").innerHTML)(ret.data);
---------------------------------------------------------------------------------------------
{{? it}} //if判断
    {{? it == 1}}
    <div>等于1的div</div>
    {{?}}
---------------------------------------------------------------------------------------------
{{?? it}} //else if判断
	<div>...</div> ... <div>...</div>
{{??}}
	如下:
    {{?? it == 2}}
    <div>等于2的div</div>
    {{?}}
//使用实例
{{?}}
 {{??}}
{{?}}
---------------------------------------------------------------------------------------------
{{for(var i in it){}} //循环遍历ret
	<div>...</div> ... <div>...</div>
{{}}}
	如下:
	{{for(var i in it){}}
        <div>{{=it[i].a)}}</div>
        <div>{{=it[i].b}}</div>
        <div>{{=it[i].c}}</div>
	{{}}}
---------------------------------------------------------------------------------------------
{{for(var ii in it[i]){}} //两次循环遍历ret中数组
	<div>...</div> ... <div>...</div>
{{}}}
	如下:
	{{for(var i in it){}}
        <div>{{=it[i].a}}</div>
            {{for(var ii in it[i]){}}
            <div>{{=it[i].b[ii]}}</div>
            {{}}}
        <div>{{=it[i].c}}</div>
	{{}}}
	
```

## 	1.2: jquery：

### 	1.2.1:页面间传值

		**页面传值用于:  例如 列表页--->详情页  [详情页面的具体显示  需要根据列表页某一项的具体 'id' ]**

**以'牧风户外'作为栗子:a_list.html页面 需要传递act_id[“此id为后台设置的活动id”]参数到b_listDetail.html页面(b页面需要取得具体的act_id才可以显示对应的详情)** [a页面参考下1代码块;b页面参考下2和jquery ajax代码块]

```
//下1
var activityId = getQueryString('activityId');
    var postData = {};//构建数组 将数据已json格式发送到后台
    postData.act_id = activityId;
```

```javascript
//下2
function getQueryString(name) {
        var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
        var r = window.location.search.substr(1).match(reg);
        if (r != null) return unescape(r[2]);
        return null;
    }
------------------------------------------------------------------------------------------------

//食用方法 1:放到页面里  或者放到js里再引入js即可 2:页面里调用
```

## 	高版本jquery  ajax用法:

```javascript
$(function(){ //jquery固定用法 页面加载时 方法即运行 类比apiready = function(){};
    $.ajax({
            url: '/path/to/file',
            type: 'default GET (Other values: POST)',
            dataType: 'default: Intelligent Guess (Other values: xml, json, script, or html)',
            data: {param1: 'value1'},
            //data:postData,
        })
        .done(function() {
            //console.log(JSON.stringify(ret))
            //console.log("success");
            此处内容搭配doT使用 or 不使用 doT 根据情况自定义
            例如 图片懒加载[图片懒加载 适用于 服务器有数据但是未加载 需要引入aui-lazyload.js]:
            new auiLazyload({
            errorImage:'../image/noimg.png'
            });
        })
        .fail(function() {
            //console.log("error");
        })
        .always(function() {
            //console.log("complete");
        });
    });
```

##  	低版本jquery  ajax用法:

```javascript
$(function(){
        $.ajax({
            url: BASE_URL + 'Wx/Notes/notesLists',
            type: 'post',
            dataType: 'json',
            headers:{'X-APICloud-APPKey':123456,'X-APICloud-APPId':123456},
            // data: {notes_id: '1'},
            //data:postData,
            success:function(ret){ //只有此处不同于高版本(目前用到的只发现此处)
                // console.log(JSON.stringify(ret))
                if(ret){
                    // console.log(ret.data);
                    // console.log(ret.msg);
                    var tpl =document.getElementById('tpl').innerHTML;
                    var circleNoteLists =doT.template(tpl);
                    document.getElementById('list').innerHTML=circleNoteLists(ret.data);
                    // 图片懒加载 适用于 服务器有数据但是未加载。
                    new auiLazyload({
                        errorImage:'../image/noimg.png'
                    });
                }

            }
        });

    });
```
## 其他

```javascript
$(function(){})

可以用 $_GET['id']  取传过来的参数  
if(typeof($_GET['slide'])=='undefined'){
		alert(0)
	}else {
		alert(1);
	}
-----------------------------------------------
window.location.href = 'tel_mask.html?title=司机电话&msg=确认拨打司机电话&tel='+tel;
-----------------------------------------------
window.location.href = "./mine/act_frequent_contact.html?activityId="+act_id+"&date_id="+date_id+"&uid="+uid;
-------------------------------------------------------
    兼容所有浏览器的关闭方法
function CloseWebPage() {
        if (navigator.userAgent.indexOf("MSIE") > 0) {
            if (navigator.userAgent.indexOf("MSIE 6.0") > 0) {
                window.opener = null; window.close();
            }
            else {
                window.open('', '_top'); window.top.close();
            }
        }
        else if (navigator.userAgent.indexOf("Firefox") > 0) {
            window.location.href = 'about:blank '; //火狐默认状态非window.open的页面window.close是无效的
            //window.history.go(-2);
        }
        else {
            window.opener = null;
            window.open('', '_self', '');
            window.close();
        }
    }

----------------------------------------------------------
    toast.custom({
        title:"请输入正确的手机号码",
        duration:2000
    });
---------------------------------------------------------
    <div style="width: 2.1rem;"><img src="{{=it[i].user_avatar ? it[i].user_avatar : '../../image/logo.png'}}" class="aui-img-round" style="height:2.1rem;width:2.1rem;" alt=""></div>
```



## 数组常用方法

	push() 向数组后面添加内容
​	unshift() 向数组前面添加内容
​	pop() 删除最后一个元素
​	shift() 删除第一个元素
​	

	join()把数组转换为字符串

```
var aaa = [1,2,3];
console.log(aaa.join("-"));
//输出的内容为 1-2-3
```

	split()把字符串转换为数组

```
var bbb = "1-2-3";
console.log(bbb.split("-"));
//输出内容为 ["1","2","3"]   ps:  split()中的连接符 要与原字符串连接符相同
```

## 定时器

setInterval( function(){} , 1000 )  		//毫秒  每过1000毫秒 执行一次方法
clearInterval() 方法可取消由 setInterval() 函数设定的定时执行操作

例如:

payPayPay = setInterval('openPay()',1000*15);
 clearInterval(payPayPay);

setTimeout()详解

```JavaScript
/**
定义函数时，小括号可以看作函数名与参数的分隔符；
在其他情况下，函数名后的小括号是函数调用符，会立即调用函数
*/
扩展:
	如果setTimeout()执行的函数需要传递参数
    settimeout('function('+data+')',time);

setTimeout(code,millisec);//code 要调用的函数后要执行的 JS 代码串

var foo= function(){console.log(123)}
window.setTimeout(foo,5000); //5s 之后执行
window.setTimeout(foo(),5000); //(因为立即执行函数)  0s 之后执行  
window.setTimeout('foo()',5000); //5s 之后执行
```

setTimeout(function(){},1000)		过1000秒后 执行方法   方法只执行一次

```javascript
html:
		<input type="text"/>
     	<button id="btn">点击发送短信</button>
js:
		var btn = document.getElementById("btn");
		var count = 5;
		var timer = null; //定时器的名字
		btn.onclick = function(){
          clearInterval(timer);
          this.disabled = true;//按钮会处于禁用状态<button type="button" disabled></button> 
          var that = this;//把btn对象给that
          timer = setInterval(sendTextMessage,1000);
          function sendTextMessage(){
            count--;
            if(count >=0){
              that.innerHTML =  "还剩余"+count+"秒";
            }else{
              	that.innerHTML = "重新发送短信";
                that.disabled = false;
                clearInterval(timer);  // 清除定时器
                count = 5;
            }
          }
		}
```

## 操作字符串

concat() 连接字符串

```javascript
var aaa = "123";
var bbb = "zsx";
var ccc = aaa.concat(bbb);
//ccc = "123zsx"
```

slice() 从已有的数组中返回选定的元素 可提取字符串的某个部分，并以新的字符串返回被提取的部分

```javascript
slice(“取字符串的起始位置”, [结束位置]) //[]可选
slice(3,6)     3  从第3个开始取     6  取到第6索引号的位置，还是从左边的第0个开始数。 但是不包括6
```

substr() 可在字符串中抽取从开始下标开始的指定数目的字符

```javascript
substr(起始位置,[取的个数])
```

splice() 用于插入、删除或替换数组的元素 

```javascript
语法:
array.splice(index,howmany,item1,.....,itemX)
			index:必需。规定从何处添加 / 删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。
			howmany:必需。规定应该删除多少元素。必须是数字，但可以是 "0"。如果未规定此参数，则删除从index 开始到原数组结尾的所有元素
            item1, ..., itemX:要添加到数组的新元素
 
/**
从原数组的第3个位置开始移除2个元素.然后再添加新元素.
var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(2,2,"Lemon","Kiwi");
输出:
["Banana","Orange","Lemon","Kiwi"]
*/
```

charAt() 方法可返回指定位置的字符 //根据位置返回字符串

indexOf() //根据字符 返回位置  从前面索引

lastIndexOf()  // 根据字符 返回位置  从后面索引

asdfgg.indexOf("f")   //3  从前面索引

lastIndexOf("g")   //5  从后面索引

## JS位置 宽高属性

### 	offset系列

​	

```javascript
offsetWidth //(获取当前对象的宽度[自己的,与他人无关!!!!]) width + border + padding
offsetHeight//(获取当前对象的高度[自己的,与他人无关!!!!]) height + border + padding

*.style.width/height  //只能得到行内的数值 即行内定义的宽高度

offsetLeft//(当前对象到其上级层(最近的且带有定位的)左边的距离)返回的是数字 若没有定位 则以body为准 [从父级的padding开始计算 父级的border不算]    {子盒子到父盒子边框到边框的距离}   		只读属性 不能赋值
offsetTop //(与上条相同)

style.top/left //可以得到具体的值(行内式)返回的是字符串  并且可以赋值
offsetParent//(返回该对象的父级(最近的父级元素 带有定位 若无定位 则为body))
```



### 	event系列

​	

```javascript
//"鼠标事件" 发生时候才会有意义
event.clientX 相对文档的水平坐标  可视区域 (跟 screenX 相比就是将参照点改成了浏览器内容区域的左上角，该参照点会随之滚动条的移动而移动)//当鼠标事件发生时，鼠标相对于浏览器（这里说的是浏览器的有效区域）x轴的位置
//设置或获取鼠标指针位置相对于当前窗口的 x 坐标，其中客户区域不包括窗口自身的控件和滚动条.（可见区域）不包含border!!!!
event.clientY 相对文档的垂直座标	可视区域//当鼠标事件发生时，鼠标相对于浏览器（这里说的是浏览器的有效区域）y轴的位置
//设置或获取鼠标指针位置相对于当前窗口的 y 坐标，其中客户区域不包括窗口自身的控件和滚动条.（可见区域）

screenX screenY 屏幕  (鼠标位置相对于用户屏幕偏移量    此时的参照点也就是原点是屏幕的左上角)//当鼠标事件发生时，鼠标相对于显示器屏幕x轴 y轴的位置
//设置或获取获取鼠标指针位置相对于用户屏幕的 x 坐标 y 坐标。(用户屏幕左上角) 

event.pageX //设置或获取鼠标指针位置相对于当前窗口的 x 坐标，其中客户区域包括窗口自身的控件和滚动条。
event.pageY //设置或获取鼠标指针位置相对于当前窗口的 y 坐标，其中客户区域包括窗口自身的控件和滚动条。

event.offsetX 相对容器的水平坐标//当鼠标事件发生时，鼠标相对于事件源x轴的位置
//设置或获取鼠标指针位置相对于触发事件的对象的 x 坐标。 （触发事件的元素,ie,chrome 支持此属性，ff 不支持）
event.offsetY 相对容器的垂直坐标//当鼠标事件发生时，鼠标相对于事件源y轴的位置
//设置或获取鼠标指针位置相对于触发事件的对象的 y 坐标。 （触发事件的元素,ie,chrome 支持此属性，ff 不支持）

event.x //设置或获取鼠标指针位置相对于父文档的 x 像素坐标 (亦即相对于当前窗口)。(ff 不支持)
event.y //设置或获取鼠标指针位置相对于父文档的 y 像素坐标 (亦即相对于当前窗口)。(ff 不支持)

event.layerX //鼠标相比较于当前坐标系的位置, 即如果触发元素没有设置绝对定位或相对定位,以页面为参考点, 如果有, 将改变参考坐标系, 从触发元素盒子模型的 border 区域的左上角为参考点 (未理解)

event.laylerY //鼠标相比较于当前坐标系的位置, 即如果触发元素没有设置绝对定位或相对定位, 以页面为参考点, 如果有, 将改变参考坐标系, 从触发元素盒子模型的 border 区域的左上角为参考点 (未理解)
```

## 事件对象:

​	http://www.runoob.com/jsref/dom-obj-event.html

## 常用事件--获取鼠标的位置

​	

```
onmousemove 事件会在鼠标指针移到指定的对象时发生 	[鼠标移动]

	onmouseout	事件会在鼠标指针移出指定的对象时发生		[离开]
	onmouseover	事件会在鼠标指针移动到指定的元素上时发生	[经过]

	onmouseenter 事件在鼠标指针移动到元素上时触发
	onmouseleave 事件在鼠标移除元素时触发

	onmousedown 事件会在鼠标按键被按下时发生
	onmouseup 事件会在鼠标按键被松开时发生
```



```javascript
onmouseover、onmouseout 一对，onmouseenter、onmouseleave 一对，不能混合使用
onmouseover onmouseout 鼠标经过时自身触发事件，经过其子元素时也触发该事件；（父亲有的东西，儿子也有）
onmouseenter onmouseleave 没有事件冒泡，其他跟 onmouseover 没有区别！！！  鼠标经过时自身触发事件，经过其子元素时不触发该事件。（父亲的东西就是父亲的，不归儿子所有）
```

```javascript
//[鼠标在一个盒子内的坐标(获取鼠标的位置)]
HTML:
<div class="zsx"></div>
js:
var div = document.getElementsByTagName("div")[0];
div.onmousemove = function(event) {
  	var event = event || window.event;
  	var x = event.clientX - this.offsetLeft;
  	var y = event.clientY - this.offsetTop;
  	this.innerHTML = x + "px" + y + "px";
}
```

## 常用事件--随便记录

```javascript

```



## 常用事件--窗口

```javascript
window.onscroll = function(){} //屏幕滚动事件
window.onresize = function(){} //窗口改变事件
```

## 事件冒泡和事件捕获 

	阻止冒泡 event.stopPropagation()

```html
<div id="parent">
　　<div id="child" class="child"></div>
</div>
```

```javascript
document.getElementById("parent").addEventListener("click",function(e){
  alert("parent事件被触发，"+this.id);
})
document.getElementById("child").addEventListener("click",function(e){
  alert("child事件被触发，"+this.id)
})
/*child事件被触发，child
  parent事件被触发，parent
*/
/*先 child，然后 parent。[事件的触发顺序自内向外]，这就是[事件冒泡]
*/
```

```javascript
document.getElementById("parent").addEventListener("click",function(e){
  alert("parent事件被触发，"+e.target.id);
},true)
document.getElementById("child").addEventListener("click",function(e){
  alert("child事件被触发，"+e.target.id)
},true)
/*parent事件被触发，parent
  child事件被触发，child
*/
/*先 parent, 然后 child。[事件触发顺序变更为自外向内]，这就是[事件捕获]
*/
```



## 获取拖拽盒子的位置

## 拖动时防止被选中

```javascript
window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty()
```



## 保留小数位数

```javascript
var num = 11223344.12345;	//假设 保留 两位小数位
console.log(num.substr(0,num.indexOf(".")+3)); //通过 indexOf  返回小数点的位置     截取字符串
console.log(parseInt(num*100) /100); //先乘以100  取整  然后 除以100
console.log(num.toFixed(2));	//toFixed() 方法
ps:	toFixed()可把 Number 四舍五入为指定小数位数的数字
```

## 大小写转换

toUpperCase()  转换为大写

toLowerCase() 转换为小写

## 访问关系(节点)

```javascript
父节点:parentNode   返回亲父亲 不管父亲是否带有定位

兄弟节点:	
	nextSibling   返回元素节点之后的兄弟节点（包括文本节点、注释节点即回车、换行、空格、文本等等）
	nextElementSibling   只返回元素节点之后的兄弟元素节点（不包括文本节点、注释节点）
	previousSibling  获取元素的上一个兄弟节点；（既包含元素节点、文本节点、注释节点）
	previousElementSibling	获取上一个兄弟元素节点；（只包含元素节点）

子节点:
	firstChild 返回被选节点的第一个子节点(既包含元素节点、文本节点、注释节点)
	firstElementChild  返回被选节点的第一个子节点(只包含元素节点)
	lastChild 返回被选节点的最后一个子节点(既包含元素节点、文本节点、注释节点)
	lastElementChild  返回被选节点的最后一个子节点(只包含元素节点)

所有子节点
	childNodes  返回节点的子节点集合，以 NodeList 对象 (既包含元素节点、文本节点、注释节点)
	children  返回节点的子节点集合，以 NodeList 对象 (只包含元素节点)



appendChild()	向节点的子节点列表的末尾添加新的子节点
createElement()	通过指定名称创建一个元素
insertBefore() 	在已有的子节点前插入一个新的子节点

nodeType()	返回节点类型
```



## == 和 ===

!= 为 == 的非运算，!== 为 === 的非运算

## break 和 continue

```javascript
break 的作用是跳出代码块, 所以 break 可以使用与循环和 switch 等

continue 的作用是进入下一个迭代, 所以 continue 只能用于循环的代码块。

代码块: 基本上是｛｝大括号之间
```



## isNaN()

isNaN() 函数用于检查其参数是否是非数字值。

## isFinite()

isFinite() 函数用于检查其参数是否是无穷大。

**提示：** 如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。

## email验证

```javascript
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title></title>
</head>
<head>
<script>
function validateForm(){
 var x=document.forms["myForm"]["email"].value;
 var atpos=x.indexOf("@");
 var dotpos=x.lastIndexOf(".");
 if (atpos<1 || dotpos<atpos+2 || dotpos+2>=x.length){
 alert("不是一个有效的 e-mail 地址");
 return false;
 }
}
</script>
</head>
<body>

<form name="myForm" action="demo-form.php" onsubmit="return validateForm();" method="post">
Email: <input type="text" name="email">
<input type="submit" value="提交">
</form>

</body>
</html>
```

## javascript:void(0) 

void() 仅仅是代表不返回任何值，但是括号内的表达式还是要运行

## DOM

```javascript
1 用指定 ID 选取元素
var x=document.getElementById("intro");
2 用指定标签名选取元素
var y=x.getElementsByTagName("p");
3 用指定 CSS 类选取元素
var x=document.getElementsByClassName("intro");
4 用指定名字选取元素
var z = document.getElementsByName('input');
5 通过 CSS 选择器选取元素
document.querySelectorAll('.div')  //匹配所有class名为div的元素
6 匹配指定 CSS 选择器的一个元素
document.querySelector("#demo") //querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代
7 获取父元素
element.parentNode // 基本都兼容
8 获取子元素
element.childNodes // 基本都兼容
//element.childNodes不止会获取到DOM，也会获取到文字等，只有当nodeType === 1时才表示DOM
9 获取前面的兄弟节点
element.previousSibling // 基本都兼容 获取所有前面的兄弟节点就是遍历previousSibling, 直到null。
10 获取后面的兄弟节点
element.nextSibling // 基本都兼容
11 创建DOM 
document.createElement(tagName)
12 新增DOM 之 添加到子节点最后
paranetElement.appendChild(child);
13 新增DOM 之 添加到节点的前面
paranetElement.insertBefore(newElement, Element)//通过insertBefore方法可以将newElement插入到Element后面，如果Element是null则将newElement插入到paranetElement的尾部

14 修改DOM
Element.innerHTML // 获取标签内的所有内容 
Element.innerText // 只获取标签内的文字内容，不包括标签
15 修改css
element.style.cssAttribute
16 修改属性
element.setAttribute() 
element.removeAttribute() 
element.className
17 删除DOM
paranetElement.removeChild(element)
18 清空子节点
没有专门的函数，可以遍历 removeChild 来实现
var element = document.getElementById("top");
while (element.firstChild) {
  element.removeChild(element.firstChild);
}

------------------------------------------------------------
创建 DOM 节点:
createElement();// 创建一个元素节点 => 接收参数为 string 类型的 nodename
createTextNode();// 创建一个文本节点 => 接收参数为 string 类型的 text 内容
createAttribute();// 创建一个属性节点 => 接收参数为 string 类型的属性名称
createComment();// 创建一个注释节点 => 接收参数为 string 类型的注释文本

 createDocumentFragment();//创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的
--------------------------------------------------------------
--------------------------------------------------------------
Range 对象 // Range 对象代表页面上的一段连续区域
var range = document.createRange();//创建一个空的 Range 对象
Selection 对象 //每一个浏览器窗口都有一个 Selection 对象，代表用户鼠标在页面中所选取的区域
var selection = window.getSelection(); 或者 var selection = document.getSelection();

/每一个 Selection 对象都有一个或多个 Range 对象，每一个 Range 对象代表用户用鼠标所选取范围内的一段连续区域/
Firefox 与 chrome，safari 对 Selection 的区别？
/*在 Firefox 浏览器中，用户可以通过按住 ctrl 键来选取页面上的多个区域，因此一个 Selection 对象可能有多个 Range 对象。
   在 chrome 或 safari 浏览器中，用户每次只能选取一段区域，所以一个 Selection 对象中只能有一个 Range 对象。*/
如何获取 Selection 对象中的某个 Range 对象呢？
var range = document.getSelection().getRangeAt(rangeIndex); //通过 Selection 对象的 getRangeAt 方法来获取

Range 对象的属性:

collapsed: (Boolean) 用于判断 Range 对象所代表的区域的开始点和结束点是否位于相同的位置，如果相同该属性值为 true。
commonAncestorContainer: (node) 返回 Range 对象所代表的区域位于什么节点之中。
endContainer: (node) 用于返回 Range 对象所代表的区域的终点位于什么节点之中。
endOffset（int） 用于返回 Range 对象所代表区域的终点与包含该终点的节点起点之间的距离。
startContainer: (node) 用于返回 Range 对象所代表区域的起点位于什么节点之中。
startOffset (int) 用于返回 Range 对象所代表的区域的起点与包含该起点节点的起点之间的距离。

Range 对象的方法:


```

## HTML5  Web 存储

```JavaScript
1 localStorage  没有时间限制的数据存储v
localStorage.setItem(key,value); //保存数据
localStorage.getItem(key); //读取数据
localStorage.removeItem(key); //删除单个数据
localStorage.clear(); //删除所有数据
localStorage.key(index); //得到某个索引的 key

2 sessionStorage 针对一个 session 的数据存储 

```



## DOM HTML

```javascript
insertAdjacentHTML 和 insertAdjacentText 
1.beforeBegin: 插入到标签开始前

2.afterBegin: 插入到标签开始标记之后

3.beforeEnd: 插入到标签结束标记前

4.afterEnd: 插入到标签结束标记后
```

## JavaScript 变量作用域

```javascript
/**
作用域即是查找变量的地方
*/

声明提前 【函数声明的提升优先级大于变量声明的提升】

变量在全局声明，或者在代码的任何位置 隐式声明(不使用var)，则该变量在全局可见

变量在函数内 显式声明(使用var)，则在该函数内可见

【如果使用var定义变量，程序会强制制定一个新变量(即使变量名相同)。】

】如果没有使用var定义变量，系统会优先在当前上下文中搜索是否存在该变量。只有在该变量不存在的前提下，系统才会重新定义一个新变量。

】

【特殊情况:   若函数的参数名和全局变量相同的话，在函数内不写 var，里面的变量会认为是形参的调用，而不会覆盖全局变量】

只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量 “提前声明”
```



```javascript
---------------------------------
祖传代码1: 特殊情况
var bb = 1;//全局变量
function aa(bb){
bb = 2;//全局变量
alert(bb+"内");
}
aa(bb);//形参的调用 不覆盖全局变量  （输出2内）
alert(bb+"外");//全局变量的值未变 （输出1外）

2内  1外
---------------------------------
祖传代码2:
var bb = 1;//全局变量 b = 1;
function aa(cc){
bb = 2;//全局变量 b = 2; 
alert(bb+"内");
}
aa(bb);//形参的调用 此时覆盖了全局变量 全局变量b == 2; (输出2内)
alert(bb+"外");//所以 也是2

2内  2外
---------------------------------
a = 1;
function foo(){
    console.log(`%c ${a}`,`color:red`);  //undefined;
    //因为该函数内重新声明了一次a变量，虽然在当前语句的后面才a变量，但是变量声明会被提升到当前函数作用域的顶部。
    //注意这里只是将声明提升到了顶部，而没有进行赋值，赋值还是在声明变量行进行，所有后面的console.log才会打印出3。
    var a = 3;
    console.log(`%c ${a}`,`color:yellow`);  //3
}
foo();
---------------------------------
    6种定义变量的方式
var function let const class import
---------------------------------
```

## apply()   call()     bind()()     ...扩展运算符

```javascript
/JavaScript 中通过 call 或者 apply 用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。简单的说就是改变函数执行的上下文，这是最基本的用法。两个方法基本区别在于传参不同/
call(obj,arg1,arg2,arg3);
/*call 第一个参数传对象，可以是null。参数以逗号分开进行传值，参数可以是任何类型。*/
在 Studen 函数里面可以将 apply 中修改成如下:
Person.call(this,name,age);

apply(obj,[arg1,arg2,arg3]) 
/*apply 第一个参数传对象，第二个参数可以是数组或者arguments 对象。
(接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下
标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传
递给被调用的函数)*/
<script type="text/javascript">
	/*定义一个人类*/
	function Person(name,age)
	{
		this.name=name;
		this.age=age;
	}
	/*定义一个学生类*/
	functionStudent(name,age,grade)
	{
		Person.apply(this,arguments);
		this.grade=grade;
	}
	//创建一个学生类
	var student=new Student("zhangsan",21,"一年级");
	//测试
	alert("name:"+student.name+"\n"+"age:"+student.age+"\n"+"grade:"+student.grade);
	//大家可以看到测试结果name:zhangsan age:21  grade:一年级
	//学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.
</script>

bind(obj,arg1,arg2,arg3)()
/**
类似call() 不过返回的是函数
*/

/**
...扩展运算符
*/
var zsx = [1,2,3,4,5];
function f(z,s,x,S,B){
	console.log(z,s,x,S,B);
}
f(...zsx);//1,2,3,4,5
```



## JavaScript作用域链 Scope Chain

```javascript
根据作用域链从内到外的优先级寻找，如果内层没有就逐步向上找，直到没找到抛出异常
```

## JavaScript闭包和 this

###### 函数生命周期:

![](file:///img/life.jpg)

```javascript
首先 for 循环不会改变作用域
JavaScript 中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里
/**
闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数
*/
/**
食用方法:
1. 定义外层函数，封装被保护的局部变量。 2. 定义内层函数，执行对外部函数变量的操作。 3. 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。
*/
```

## var let const 区别 

```javascript
const 定义的变量不可以修改，而且必须初始化。
var 定义的变量可以修改，如果不初始化会输出 undefined，不会报错。
let 是块级作用域，函数内部使用 let 定义后，对函数外部无影响。
```

## console.神奇用法 

```JavaScript
console.log() == console.info()
%s  字符串
%d	整数
%i	整数
%f	浮点数
%o	对象的链接
%c	css格式字符串
console.log('%c213123213','color:red;background:yellow;font-size:30px');  // %c
```

## JavaScript运行机制详解

[](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)    JavaScript 运行机制详解：再谈 Event Loop

[](http://www.ruanyifeng.com/blog/2013/11/stack.html)   Stack 的三种含义

[](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)

[](http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html) 比特币

[](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html) 数字签名

[](http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html)  区块链

[](http://www.ruanyifeng.com/blog/2018/01/cryptocurrency-tutorial.html)  加密货币的本质

```JavaScript
二:任务队列

所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入 "任务队列"（task queue）的任务，只有 "任务队列" 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
	/*异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）*/
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个 "任务队列"（task queue）。只要异步任务有了运行结果，就在 "任务队列" 之中放置一个事件。

（3）一旦 "执行栈" 中的所有同步任务执行完毕，系统就会读取 "任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。

三:

---------------------------
    Stack 的三种含义:
1:数据结构
stack 的第一种含义是一组数据的存放方式，特点为 LIFO，即后进先出（Last in, first out）。

2:代码运行方式
stack 的第二种含义是 "调用栈"（call stack），表示函数或子例程像堆积木一样存放，以实现层层调用。
程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直至完成整个调用栈，返回最后的结果
3:内存区域
stack 的第三种含义是存放数据的一种内存区域。程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做 stack（栈），另一种叫做 heap（堆）

stack 是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；heap 是没有结构的，数据可以任意存放。因此，stack 的寻址速度要快于 heap。[所有的对象都存放在 heap]
[内存泄漏都发生在 heap，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收]
```

## "~" 和 ">" 和"+"

```css
/**
~  的用法
*/
p~ul{
　　background:#ff0000;
}
<p> 快乐生活 </p>
<ul>
　　<li> 生活 </li>
　　<li> 生活 </li>
　　<li> 生活 </li>
</ul>
/**
p~ul 选择器 p 之后出现的所有 ul。
两种元素必须拥有相同的父元素，但是 ul 不必直接紧随 p。
*/

/**
> 的用法
*/
css3 特有的选择器，A>B 表示选择 A 元素的所有子 B 元素。
与 A B 的区别在于，A B 选择所有后代元素，而 A>B 只选择一代(只选择第一代)。
.a，.b｛逗号指相同的 css 样式｝；
.a .b｛空格指后代元素｝；
.a>.b｛大于号指子代元素｝；

/**
+ 的用法
*/
A+B 表示 HTML 中紧随 A 的 B 元素：用一个结合符只能选择两个相邻兄弟中的第二个元素
li + li {font-weight:bold;}  

把列表中的第二个及后面的变为粗体。第一个列表项不受影响
```

## 伪元素和伪类区别:

```javascript
/**
伪类和伪元素的区别:
	是否创建了新的元素
*/
伪元素:
/**
伪元素为 DOM 树没有定义的虚拟元素。不同于其他选择器，它不以元素为最小选择单元，它选择的是元素指定内容[不存在在 DOM 文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中]   {用于将特殊的效果添加到某些选择器}
*/
伪类:
/**
伪类用于选择 DOM 树之外的信息，或是不能用简单选择器进行表示的信息。前者包含那些匹配指定状态的元素，比如:visited，:active；后者包含那些满足一定逻辑条件的 DOM 树中的元素，比如:first-child，:first-of-type，：target  {用于向某些选择器添加特殊的效果}
*/
```

| 伪元素         | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| ::first-line   | 选择指定元素的第一行 [设置对象内の第一行的样式]              |
| ::first-letter | 选择指定元素的第一个单词 [设置对象内の第一个字符的样式]      |
| ::before       | 在指定元素的内容前面插入内容[ 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和 content 属性一起使用 ] |
| ::after        | 在指定元素的内容后面插入内容 [ 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和 content 属性一起使用 ] |
| ::placeholder  | 设置对象文字占位符的样式                                     |
| ::selection    | 选择指定元素中被用户选中の内容[设置对象被选择の颜色] <br />{ 只可以应用于少数的 CSS 属性：color, background, cursor, 和 outline } |

| 伪类                  | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| : link                | 设置超链接a未访问前的样式                                    |
| :visited              | 设置超链接 a 在其链接地址已被访问过时的样式                  |
| :hover                | 设置元素在其鼠标悬停时的样式                                 |
| :active               | 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式 |
| :foucs                | 设置元素在成为输入焦点（该元素的 onfocus 事件发生）时的样式  |
| :lang(zsx)            | 选择带有指定 lang 属性值等于"zsx"  lang="zsx"的元素          |
| :not(p)               | 选择不满足的p的元素                                          |
| :root                 | 选择文档的根元素                                             |
| : first-child         | 选择父元素的第一个子元素                                     |
| : last-child          | 匹配父元素的最后一个子元素                                   |
| : only-child          | 匹配父元素仅有的一个子元素 (父元素只有一个子元素)            |
| : nth-child(n)        | 匹配父元素的第 n 个子元素                                    |
| : nth-last-child(n)   | 匹配父元素的倒数第 n 个子元素                                |
| : first-of-type       | 选择满足是其父元素的第一个某类型子元素的元素                 |
| : last-of-type        | 选择满足是其父元素的最后一个某类型子元素的元素               |
| : only-of-type        | 选择满足是其父元素的唯一一个某类型子元素的元素               |
| : nth-of-type(n)      | 选择满足是其父元素的第 n 个某类型子元素的元素                |
| : nth-last-of-type(n) | 选择满足是其父元素的倒数第 n 个某类型子元素的元素            |
| : empty               | 选择没有子元素的元素                                         |
| : checked             | 匹配用户界面上处于选中状态的元素 E。(用于 input type 为 radio 与 checkbox 时) |
| : enabled             | 匹配用户界面上处于可用状态的元素                             |
| :disabled             | 匹配用户界面上处于禁用状态的元素                             |
| :target               | 匹配相关 URL の指向 [ 选择当前的锚点元素 ]                   |
| :invalid              | 用于表单中の值是非法时设置的指定の样式                       |
| : in-range            | 只作用于能指定区间值的元素，例如 input 元素中的 min 和 max 属性 |
| :out-of-range         | 只作用于能指定区间之外值的元素，例如 input 元素中的 min 和 max 属性 |
| : optional            | 表单元素中如果没有特别设置 required 属性即为 optional 属性   |
| :read-only            | 用于选取设置了 "readonly" 属性的元素                         |
| :read-write           | 用于匹配可读及可写的元素                                     |
| : required            | 在表单元素是必填项时设置指定样式                             |
| :focus-within         | 元素自身或某个后代匹配:focus伪类                             |



## web  workers

```JavaScript

```

## cloneNode ()

```javascript
/**
拷贝所有属性和值
*/
<ul id="myList1">
    <li>1-1</li>
	<li>1-2</li>
</ul>
<ul id="myList2">
    <li>2-1</li>
	<li>2-2</li>
</ul>

var item = document.getElementById('myList2').lastChild;//lastChild firstChild
var clone = item.cloneNode(true);//cloneNode 本文主角
document.getElementById('myList1').appendChild(clone);//appendChild() 向节点的子节点列表添加新的子节点
```

##createElement()   &&   createTextNode()

```javascript
<ul id="list">
    <li>f</li>
	<li>u</li>
	<li>c</li>
</ul>
var node = document.createElement('li');//创建一个节点
var textnode = document.createTextNode('k');//创建一个文本节点
node.appendChild(textnode);//将文本节点添加到li节点上
document.getElementById('list').appendChild(node);//最后将节点添加到列表中
//输出fuck
```

## emmet的使用 之奇技淫巧

```css

```

## 柯里化 curry

```JavaScript
/**只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。*/
function addX(y) {
	console.log("y="+y);
   return function (x) { 
	console.log("x="+x);
    return x + y;
    /**
    后面三行不运行,都退出了,运行尼玛币
    */
	console.log("运行?????");
	console.log("x="+x);
	console.log("y="+y);
   }; 
}
var newAdd =  addX(2) 
 newAdd (1) 
/**
输出:
y=2
x=1
3
*/
```

## this详解 [可能是东半球关于此问题解释的第二清楚的了]

```javascript
//他妈的关于this
//链接:http://webcache.googleusercontent.com/search?q=cache:http://yuyang.date/2017/09/30/%25E3%2580%2590JavaScript%25E3%2580%2591this%25E5%2585%25A8%25E8%25A7%25A3%25E6%259E%2590/&strip=1&vwsrc=0
1:普通函数
	作为普通函数调用时,其 this 指向全局 window
    //当严格模式时 'use strict' 此时this将显示undefined(因为没有调用者)
    function outer(){
      function inner(){
        console.log(this);
      }
      inner(); // 内部this指向window
    }
    outer();
2:方法函数
	当方法调用的时候指向其调用者
    var obj = {
      test: function () {
        console.log(this)
      }
    }
    // 调用者为obj, 故指向obj
    obj.test()
--------------------------
	var outerObj = {
      innerObj: {
        fn: function () {
          console.log(this)
        }    
      }
    }
    // this指向outerObj.innerObj
    outerObj.innerObj.fn()
----------------------------
[调用者指的是执行时的直接调用者,而不是声明时的存储位置]
	var obj1 = {
      test: function () {
        console.log(this)
      }
    }
    const obj2 = {}
    // 将obj1的test方法引用给obj2的fn
    obj2.fn = obj1.test
    // 调用者为obj2, 故指向obj2
    obj2.fn()
3:当用 apply 和 call 上下文调用的时候指向传入的第一个参数
4:构造函数/class 函数 及其 super
	构造函数调用时指向实例对象
    new 的过程:
    1 隐式创建一个内部的空对象
    2 将内部对象的原型与构造函数的原型链连接
    3 执行构造函数内部代码, 此时 this 执行内部对象
    4 若没有显式的返回对象时, 返回我们的内部对象。(若有显式的返回对象时, 则按普通函数返回)
    我们可以用 JavaScript 大致模拟一下其过程。
    function mockNewProcess (constructor, arg) {
      var obj = {}
      obj.__prototype__ = constructor.prototype
      constructor.apply(obj, arg)
      return obj
    }
5:ES6箭头函数  ????
```

## JavaScript数据类型

```javascript
1:基本数据类型    typeof 只可以检测出基本数据类型   typeof null == 'object' 为历史bug
	Number，String，Boolean，Undefined，Null,Symbol(ES6中新添加)
	[字符串（String）、数字 (Number)、布尔 (Boolean)、对空（Null）、未定义（Undefined）、Symbol]
2:引用数据类型
	对象 (Object)、数组 (Array)、函数 (Function)


任何对象转为布尔值，都为得到 true（切记！在 JS 中，只有 0，-0，NaN，""，null，undefined 这六个值转布尔值时，结果为 false
```

## JavaScript保留字

## JavaScript全局函数

## JavaScript深拷贝和浅拷贝

```JavaScript
/**
如何区分深拷贝与浅拷贝，简单点来说，就是假设 B 复制了 A，当修改 A 时，看 B 是否会发生变化，如果 B 也跟着变了，说明这是浅拷贝，拿人手短，如果 B 没变，那就是深拷贝，自食其力

{深拷贝只针对较为复杂的object数据类型}
[深拷贝是拷贝对象各个层级的属性]
*/
var a=[0,1,2,3,4],
    b=a;
console.log(a===b);
a[0]=1;
console.log(a,b);//a == [1,1,2,3,4]; b == [1,1,2,3,4];

1:基本数据类型:名称和值都存在于 栈内存 中.
	  栈内存
  name    value
    a        1
    b		 1
2:引用数据类型:名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值.
	  栈内存							堆内存
  name	   value						val
	a	   堆地址 1				   [0,1,2,3,4]

当 b=a进行拷贝时,其实是复制的是 a的引用地址 而非 堆里的值.

      栈内存							堆内存
  name	   value						val
	a	   堆地址 1				   [0,1,2,3,4]
	b	   堆地址 1
而当我们 a[0]=1 时进行数组修改时，由于 a 与 b 指向的是同一个地址，所以自然 b 也受了影响，这就是所谓的浅拷贝了.

//实现深拷贝如下:
//通过递归去复制所有层级的属性
function deepClone1(obj){
    var objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
var a=[1,2,3,4],
    b=deepClone1(a);
a[0]=2;
console.log(a,b);//a == [2,2,3,4]  b == [1,2,3,4]

//通过JSON.stringify() 和 JSON.parse() 实现深拷贝
function deepClone2(obj){
    var _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}    
var a=[0,1,[2,3],4],
    b=deepClone2(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);// a == [1,1,[1,3],4]  b == a=[0,1,[2,3],4]
```



## Aarray对象

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array

数组属性

| 属性        | 描述                                                         | (补充...)                                                    |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| constructor | 返回值是函数的引用，不是函数名                               | JavaScript 数组 constructor 属性返回 **function Array() { [native code] }**<br />JavaScript 数字 constructor 属性返回 **function Number() { [native code] }<br />JavaScript 字符串 constructor 属性返回 **function String() { [native code] } |
| length      | 可设置或返回数组中元素的数目<br />设置数组的数目：<br />array*.length=*number |                                                              |
| prototype   | 允许你向数组对象添加属性或方法                               | 当构建一个属性，所有的数组将被设置属性，它是默认值;<br />在构建一个方法时，所有的数组都可以使用该方法.<br />**注意：** Array.prototype 单独不能引用数组, Array() 对象可以。<br />**注意：** 在 JavaScript 对象中，Prototype 是一个全局属性。 |

Array对象方法  (以MDN为准)

| 方法                                   | 描述                                                         | (补充...)                                                    |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| concat                                 | 连接两个或更多的数组，并返回结果<br />该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本 | concatenate串联<br />语法:<br />*array1*.concat(*array2*,*array3*,...,*arrayX*)<br />该参数可以是具体的值，也可以是数组对象。可以是任意多个 |
| copyWithin                             | 用于从数组的指定位置拷贝元素到数组的另一个指定位置中<br />(一个数组中进行操作) | 语法:<br />array.copyWithin(target, start, end)<br />target  必需.复制到指定目标索引位置。<br />start    可选.元素复制的起始位置。<br />end     可选.停止复制的索引位置 (默认为 *array*.length)。如果为负值，表示倒数<br />例子:<br />var arr = [1,2,3,4,5,6]; <br />arr.copyWithin(2,0); <br />[1,2,1,2,3,4] |
| entries                                | 数组的迭代对象，该对象包含数组的键值对 (key/value)           |                                                              |
| every                                  | 用于检测数组所有元素是否都符合指定条件（通过函数提供）       | every() 方法使用指定函数检测数组中的所有元素：<br />如果数组中检测到有一个元素不满足，则整个表达式返回 *false* ，且剩余的元素不会再进行检测。 <br />如果所有元素都满足条件，则返回 true。<br />every() 不会对空数组进行检测。<br />every() 不会改变原始数组。 |
| fill                                   | 用于将一个固定值替换数组的元素(会全部替换)                   | 语法:<br />array.fill(value, start, end)<br />必选 填充的值。<br />可选 开始填充位置。<br />可选 停止填充位置 (默认为 *array*.length) |
| filter                                 | 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 | filter() 不会对空数组进行检测。filter() 不会改变原始数组<br />array.filter(function(currentValue,index,arr), thisValue)<br />function(currentValue, index,arr)<br />必须。函数，数组中的每个元素都会执行这个函数<br />currentValue必须 当前元素的值<br />index 可选。当前元素的索引值<br />arr 可选。当前元素属于的数组对象<br /><br />thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。<br/>如果省略了 thisValue ，"this" 的值为 "undefined" |
| find                                   | 方法返回通过测试（函数内判断）的数组的第一个元素的值         | 方法为数组中的每个元素都调用一次函数执行:<br />当数组中的元素在测试条件时返回 *true* 时, find() 返回符合条件的元素，之后的值不会再调用执行函数<br />如果没有符合条件的元素则返回undefined<br /><br />find() 对于空数组，函数是不会执行的<br />find() 并没有改变数组的原始值<br />参数:<br />array.find(function(currentValue, index, arr),thisValue)具体描述参考filter方法 |
| findIndex                              | 返回传入一个测试条件（函数）符合条件的数组第一个元素位置     | findIndex() 方法为数组中的每个元素都调用一次函数执行：<br />当数组中的元素在测试条件时返回 *true* 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数<br />如果没有符合条件的就返回-1<br /><br />findIndex() 对于空数组，函数是不会执行的<br />findIndex() 并没有改变数组的原始值<br />语法:<br />array.findIndex(function(currentValue, index, arr), thisValue)具体参考上2行方法 |
| forEach                                | 用于调用数组的每个元素，并将元素传递给回调函数               | forEach() 对于空数组是不会执行回调函数的<br />array.forEach(function(currentValue, index, arr), thisValue)参考上3行方法 |
| from                                   | 用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组<br />如果对象是数组返回 true，否则返回 false<br />Set()方法了解一下 | Array.from(object, mapFunction, thisValue)<br />必需，要转换为数组的对象。<br />可选，数组中每个元素要调用的函数。<br />可选，映射函数 (mapFunction) 中的 this 对象。 |
| includes                               | 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则 false | arr.includes(searchElement, fromIndex)<br />必须。需要查找的元素值<br />可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0 |
| indexOf                                | 返回数组中某个指定的元素位置                                 | 该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。开始位置的索引为 0。<br />如果在数组中没找到指定元素则返回 -1<br />*array*.indexOf(*item*,*start*)<br />必须。查找的元素。<br />可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。 |
| lastIndexOf                            | 略                                                           | 类似上1行,此处略                                             |
| isArray                                | 用于判断一个对象是否为数组                                   | Array.isArray(obj)                                           |
| join                                   | 把数组中的所有元素转换一个字符串                             | *array*.join(*separator*)<br />可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符<br />返回值:<br />返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。 |
| keys                                   | 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键<br />如果对象是数组返回 true，否则返回 false。 | array.keys()                                                 |
| map                                    | 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值<br />按照原始数组元素顺序依次处理元素 | map() 不会对空数组进行检测<br />map() 不会改变原始数组<br />array.map(function(currentValue,index,arr), thisValue)略... |
| pop                                    | 删除数组的 最后一个 元素并返回删除的元素                     | *array*.pop()<br />此方法改变数组的长度！                    |
| shift                                  | 把数组的 第一个 元素从其中删除，并返回第一个元素的值         | *array*.shift()<br />此方法改变数组的长度！                  |
| push                                   | 向数组的末尾添加一个或多个元素，并返回新的长度<br />新元素将添加在数组的末尾 | *array*.push(*item1*, *item2*, ..., *itemX*)<br />必需。要添加到数组的元素<br />此方法改变数组的长度。<br />返回值类型 Number |
| unshift                                | 向数组的开始添加一个或多个元素，并返回新的长度<br />新元素将添加在数组的开始 | *array*.unshift(*item1*,*item2*, ..., *itemX*)上同略         |
| reduce                                 | 接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 | 语法:<br />array.reduce(function(total, currentValue, currentIndex, arr), initialValue)<br />必需。用于执行每个数组元素的函数。<br/>   函数参数:<br />          必需。*初始值*, 或者计算结束后的返回值。<br />          必需。当前元素<br />          可选。当前元素的索引<br />          可选。当前元素所属的数组对象。<br />可选。传递给函数的初始值 |
| reduceRight                            | 将数组元素计算为一个值（从右到左）                           | 略...                                                        |
| reverse                                | 颠倒数组中元素的顺序                                         | *array*.reverse()                                            |
| slice                                  | 从已有的数组中返回选定的元素<br />可提取字符串的某个部分，并以新的字符串返回被提取的部分<br />不会改变原数组 | *array*.slice(*start*, *end*)   [start,end)<br />参数:<br />可选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。<br />可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 |
| splice                                 | 插入、删除或替换数组的元素<br />会改变原始数组!              | *array*.splice(*index*,*howmany*,*item1*,.....,*itemX*)<br />必需。规定从何处添加 / 删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字。<br />必需。规定应该删除多少元素。必须是数字，但可以是 "0".如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。<br />可选。要添加到数组的新元素 |
| sort                                   | 对数组的元素进行排序<br />排序顺序可以是字母或数字，并按升序或降序。<br />默认排序顺序为按字母升序<br />这种方法会改变原始数组! | 使用数字排序，你必须通过一个函数作为参数来调用。<br />函数指定数字是按照升序还是降序排列<br />*array*.sort(*sortfunction*)<br />可选。规定排序顺序。必须是函数。 |
| some                                   | 检测数组中的元素是否满足指定条件（函数提供）<br />some() 方法会依次执行数组的每个元素:如果有一个元素满足条件，则表达式返回 *true* , 剩余的元素不会再执行检测,如果没有满足条件的元素，则返回 false<br />some() 不会对空数组进行检测<br />some() 不会改变原始数组 | array.some(function(currentValue,index,arr),thisValue)<br />some() 不会对空数组进行检测<br />some() 不会改变原始数组 |
| toString                               | 把数组转换为字符串，并返回结果<br />数组中的元素之间用逗号分隔 | *array*.toString()<br />返回值string                         |
| valueOf                                | 返回 Array 对象的原始值                                      | 返回数组值                                                   |
| 目前还缺少的部分在MDN上 有空再补充.... |                                                              |                                                              |
|                                        |                                                              |                                                              |
|                                        |                                                              |                                                              |
|                                        |                                                              |                                                              |

## String对象

| 属性 | 描述 | 补充... |
| ---- | ---- | ------- |
|      |      |         |
|      |      |         |
|      |      |         |
|      |      |         |
|      |      |         |
|      |      |         |
|      |      |         |
|      |      |         |
|      |      |         |



## 正则表达式

学一门前端工具，几年就过时了。学正则表达式，受用一辈子

JavaScript RegExp 对象

```JavaScript
语法:
/**
pattern（模式） 描述了表达式的模式
modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配
*/
/**
例如:检查手机号  
var mobile_check = document.getElementById("mobile").value;
var phoneRule = /^0?1[3|4|5|7|8][0-9]\d{8}$/;
phoneRule.test(mobile_check)
*/

/**
当使用 构造函数 创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：
var re = new RegExp("\\w+");
var re = /\w+/;
*/
var patt=new RegExp(pattern,modifiers);
或者更简单的方式:
var patt=/pattern/modifiers;
//pattern(模式)描述了表达式的模式  modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配

				修饰符:
/**
修饰符用于执行区分大小写和全局匹配和多行匹配
*/
修饰符	  描述
i		执行对大小写不敏感的匹配。
g		执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
m		执行多行匹配。

				方括号:
/**
方括号用于查找某个范围内 [纵向 模糊匹配] 的字符   方括号也可以称之为 字符组(字符类)
*/
表达式	描述
[abc]	查找方括号之间的任何字符。//其中的任何一个单一字符
[^abc]	查找任何不在方括号之间的字符。//^取反,即表示除a b c之外任何的字符
[0-9]	查找任何从 0 至 9 的数字。
[a-z]	查找任何从小写 a 到小写 z 的字符。
[A-Z]	查找任何从大写 A 到大写 Z 的字符。
[A-z]	查找任何从大写 A 到小写 z 的字符。
[adgk]	查找给定集合内的任何字符。//????
[^adgk]	查找给定集合外的任何字符。//????
(red|blue|green)	查找任何指定的选项。
// | 管道符 多选分支 red blue green 是3个子模式;
//栗子:	goodGirl  使用/good|goodGirl/匹配时,结果是good,多选分支也是惰性的(前面符合就不再匹配后面)
//栗子:匹配16进制颜色 /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g   注意顺序!!!!

/**
栗子:匹配时间24小时制 23:59 02:32  11:11
第一位:
	可以为[0-2]
	情况Ⅰ当2时:
	情况Ⅱ当0或1时:
第二位:
	情况Ⅰ[0-3]
	情况Ⅱ[0-9]
第三位:
	情况Ⅰ[0-5]
	情况Ⅱ[0-5]
第四位:
	情况Ⅰ[0-9]
	情况Ⅱ[0-9]

终极最笨!!!: /2[0-3]:[0-5]{1,2}[0-9]{1,2}|0[0-9]:[0-5]{1,2}[0-9]{1,2}|1[0-9]:[0-5]/g

完蛋玩意儿!!!!:	/^([01][0-9]|[2][0-3]):[0-5][0-9]$/g
*/  

/**
匹配日期 yyyy-mm-dd 格式:
年:[0-9]{4}
月:0[1-9]|1[0-2]
日:0[0-9]|[12][0-9]|3[0-1]

/^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/g
*/

/**
匹配window操作系统文件路径:
G:\daybyday3\JavaScript正则表达式迷你书

盘符:[a-zA-Z]:\\
文件夹:([^\\:*<>|"?\r\n/]+\\)*
文件夹(最后一层):([^\\:*<>|"?\r\n/]+)?

	/^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/
*/

				元字符:
/**
元字符（Metacharacter）是拥有特殊含义的字符
即 系统自带的简写形式
*/
元字符	描述
[^]或[\w\W]或[\d\D]或[\s\S] 
//匹配任意字符 

.	查找单个字符，除了换行和行结束符。
// 	/.^/不匹配任何东西 .单个字符 ^又匹配开头 so 啥都木有!
//[^\n\r\u2028\u2029]通配符 除 换行符 回车符 行分隔符 段分隔符 之外的其他任何字符(想一下省略号...中的每个点,)

\w	查找单词字符。
=//[0-9a-zA-Z_]表示 数字 大小写字母和下划线,也称单词字符(不是单指"单词"!!!!).(w即word 如此记忆)
\W	查找非单词字符。//非单词字符

\d	查找数字。//[0-9]表示数字.(digit英文数字的意思)
//数字千位分隔符表示法 var result = "12345678".replace(/(?=(\d{3})+$)/g ,',') 
//	等价于 /?=([0-9]{3}+$)/g   
//完美版: /(?!^)(?=(\d{3})+$)/g    1,234,567,890,123
//变种: /(?!\b)(?=(\d{3})+\b)/g    即 /\B(?=(\d{3})+\b)/g
//var test = (1234567890).toFixed(2).replace(/\B(?=(\d{3})+\b)/g ,',').replace(/^/g,'$');
//$1,234,567,890.00
\D	查找非数字字符。//表示除数字之外的任意字符
\s	查找空白字符。//[\t\v\n\r\f]表示空白字符,空格 水平&垂直制表符 换行符 回车符 换页符(s space white space 空白格 如此记忆)
\S	查找非空白字符。//参上

\b	匹配单词边界。//具体就是\w 与 \W之间的位置,也包括\w 与 ^之间的位置,和\w 与 $之间的位置
\B	匹配非单词边界。

\0	查找 NULL 字符。

\n	查找换行符。
\f	查找换页符。
\r	查找回车符。
\t	查找水平制表符。
\v	查找垂直制表符。

\xxx	查找以八进制数 xxx 规定的字符。
\xdd	查找以十六进制数 dd 规定的字符。
\uxxxx	查找以十六进制数 xxxx 规定的 Unicode 字符。

				量词:
//又被叫做 重复  下面的都是系统自带的一些简写形式   [横向 模糊匹配]

量词	描述
n+	匹配任何包含至少一个 n 的字符串。
//(+ 等价于 {1,} 表示至少出现一次. +号好比追加,必须得现有1个才考虑追加,四哥哥如是说)
//例如，/a+/ 匹配 "candy" 中的 "a"，"caaaaaaandy" 中所有的 "a"。

n*	匹配任何包含零个或多个 n 的字符串。
//(* 等价于 {0,} 表示出现任意次,亦可能不出现. 天上的星星可能无数 亦可能零星几颗 或可能一颗都没有...)
//例如，/bo*/ 匹配 "A ghost booooed" 中的 "boooo"，"A bird warbled" 中的 "b"，但是不匹配 "A goat grunted"。

n?	匹配任何包含零个或一个 n 的字符串。
//(? 等价于 {0,1} 表示出现或者不出现.	有吗? 如此理解)
//例如，/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"。/\d{2,5}?/数字2个到5个,但当2个就够的时候就不继续往下寻找

n{x}	匹配包含 x 个 n 的序列的字符串。
//(x 等价于 {x,x} 表示出现x次)
//例如，/a{2}/ 不匹配 "candy," 中的 "a"，但是匹配 "caandy," 中的两个 "a"，且匹配 "caaandy." 中的前两个 "a"。

n{x,}	X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。
//(表示至少出现x次)
//例如，/a{2,}/ 不匹配 "candy" 中的 "a"，但是匹配 "caandy" 和 "caaaaaaandy." 中所有的 "a"。

n{x,y}	X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。
//例如，/a{1,3}/ 不匹配 "cndy"，匹配 "candy," 中的 "a"，"caandy," 中的两个 "a"，匹配 "caaaaaaandy" 中的前面三个 "a"。注意，当匹配 "caaaaaaandy" 时，即使原始字符串拥有更多的 "a"，匹配项也是 "aaa"。
$	匹配结尾
^   匹配开头
n$	匹配任何结尾为 n 的字符串。
^n	匹配任何开头为 n 的字符串。

?=n	匹配任何其后紧接指定字符串 n 的字符串。
//positive lookahead (正向先行断言) n前面的位置(使用时最好添加括号) 栗子:var test = 'zsx'.replace(/(?=zsx)/g,'zsx2'); console.log(test);
?!n	匹配任何其后没有紧接指定字符串 n 的字符串。
//negative lookahead(负向先行断言)  与上一条相反

/**
{}可以理解为 "贪婪匹配" 
{}?可以理解为 "惰性匹配" //量词后面添加? 实现"惰性匹配"
*/
```

RegExp 对象方法

支持正则表达式的 String 对象的方法

RegExp 对象属性

## JavaScript正则表达式迷你书有感

```JavaScript
//反向引用(分组匹配)
var test = /^((\d)(\d(\d)))\1\2\3\4$/
var string = '1231231233';
console.log(test.test(string));//true
console.log(RegExp.$1,RegExp.$2,RegExp.$3,RegExp.$4);//123 1 23 3

//详解: 测试环境    Chrome浏览器
var str = "ABCDE";
var reg = /(A+)((B|C|D)+)(E+)/gi;
str.match(reg);//输出：["ABCDE"]
reg.exec(str,'i');//输出：["ABCDE", "A", "BCD", "D", "E"]
RegExp.$1;//输出："A"
RegExp.$2;//输出："BCD"
RegExp.$3;//输出："D"
RegExp.$4;//输出："E"
/**
元字符 \1 \2 ... \9   "\num" (num:1-99的整数) 用法:用来表示前面以匹配的字符或分组的一个引用
*/

你*了个*!看的脑仁疼!  过段时间再看!你**的*子!!!
```

## 杂物之阅后即瞎

```JavaScript
//JavaScript页面刷新
<meta http-equiv="refresh" content="5">//每过5秒自动刷新
location.reload();//刷新当前文档
window.location.replace("http://www.runoob.com")//replace() 方法可用一个新文档取代当前文档
```

